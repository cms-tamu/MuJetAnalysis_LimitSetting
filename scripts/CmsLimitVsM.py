import math
from math import *
from scipy.stats import chisquare
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import numpy as np

def myGaus(x, mu, sigma):
  return 1./( sigma * sqrt(2.0*pi) ) * exp( - (x - mu)*(x - mu) / 2.0/sigma/sigma )

def myGaus2(x, mu, sigma):
  return exp( - (x - mu)*(x - mu) / 2.0/sigma/sigma )

def fCmsLimitVsM(m):
  #M = 0.315
  #LimitMin = 3.08
  #LimitMax = 8.55
  #if False:
  #  print "M = ", M
  #  print "LimitMin = ", LimitMin
  #  print "LimitMax = ", LimitMax
  #  print "sigma = ", fCmsResolution(M)
  #  print "myGaus(M, M, fCmsResolution(M) ) = ", myGaus(M, M, fCmsResolution(M) )
  #  print "LimitMax-LimitMin/myGaus[M,M,sigma(M)]/sigma(M)sqrt(2pi) = ", (LimitMax - LimitMin)/myGaus(M, M, fCmsResolution(M) )/fCmsResolution(M)/sqrt(2.0*pi)
  #  print "1/2/sigma(M)^2 = ", 1.0/2.0/fCmsResolution(M)/fCmsResolution(M)
  #  print "Err: " + str(LimitMin + (LimitMax - LimitMin)*myGaus(m, M, fCmsResolution(M) )/myGaus(M, M, fCmsResolution(M) ))
  #return LimitMin + (LimitMax - LimitMin)*myGaus(m, M, fCmsResolution(M) )/myGaus(M, M, fCmsResolution(M) )
#****************************************
# old method 95 CL v2

  ## 90% CL
  return 2.33591576728+0.490467147856* myGaus2(m,1.20105406966, 0.0158823287785) + 1.75* myGaus2(m,1.37980913362, 0.0363780607304) + 0.468148031032* myGaus2(m,1.89383556463, 0.0619017859509) + 1.2* myGaus2(m,2.37120887758, 0.0524109033795) + 2.04831493617* myGaus2(m,2.84399373813, 0.07) + 4.482483411* myGaus2(m,3.05938898807, 0.0696193158778)

  ## 95% CL
  #return 3.00174326806+0.758400444753* myGaus2(m,1.21537045458, 0.0402388548379) + 1.81322228899* myGaus2(m,1.4117157352, 0.05) + 0.581002295405* myGaus2(m,1.90264292745, 0.0648260169513) + 1.46155733387* myGaus2(m,2.37797756173, 0.0585759605432) + 1.84612408697* myGaus2(m,2.80000000002, 0.07) + 4.89437383246* myGaus2(m,3.04849077039, 0.09)

def fCmsLimitVsM_explicit(m):
  A = 3.082
  B = 1.18
  C = 552.0
  M = 0.315
  return A + B*exp( -552*(m - M)*(m - M) )

def fCmsResolution ( m ):
  return (0.13 + m*0.065)/5.0

Limits_HybridNew = [
[0.2113,2.32519152091], #(263)
[0.24,2.31384589354], #(263)
[0.26,2.31599923954], #(263)
[0.3,2.28653072243], #(263)
[0.33,2.30740821293], #(263)
[0.36,2.31562452471], #(263)
[0.4,2.34472664122], #(262)
[0.43,2.31482809886], #(263)
[0.46,2.29602984733], #(262)
[0.5,2.31049174905], #(263)
[0.53,2.32602076336], #(262)
[0.56,2.32699973077], #(260)
[0.6,2.33462676806], #(263)
[0.7,2.33536238462], #(260)
[0.8,2.31982150579], #(259)
[0.88,2.34314081712], #(257)
[0.9,2.31826914729], #(258)
[0.91,2.37103], #(253)
[0.92,2.32488453125], #(256)
[0.93,2.32189509653], #(259)
[0.94,2.35398964981], #(257)
[1.0,2.30227392157], #(255)
[1.1,2.32948281369], #(263)
[1.2,2.82531612167], #(263)
[1.3,2.47856250951], #(263)
[1.4,3.82357212928], #(263)
[1.5,2.55500026616], #(263)
[1.6,2.36561607692], #(260)
[1.7,2.327021875], #(256)
[1.8,2.48492144487], #(263)
[1.9,2.80170961977], #(263)
[2.0,2.44285657795], #(263)
[2.1,2.35771823529], #(255)
[2.2,2.34996177419], #(248)
[2.3,2.80477813688], #(263)
[2.4,3.35056072243], #(263)
[2.5,2.42792961977], #(263)
[2.6,2.36458232824], #(262)
[2.7,2.80620239544], #(263)
[2.8,3.96286365019], #(263)
[2.9,4.1693318251], #(263)
[3.0,5.68134539924], #(263)
[3.02,6.36000292776], #(263)
[3.05,6.56074973384], #(263)
[3.08,6.55068714829], #(263)
[3.09,6.34446718631], #(263)
[3.1,6.22982224335], #(263)
[3.12,5.72968596958], #(263)
[3.15,4.1876078327], #(263)
[3.2,2.5511689313], #(262)
[3.3,2.34780830116], #(259)
[3.4,2.35428200787], #(254)
[3.7,2.34875946058], #(241)
[4.0,2.33520411067], #(253)
[5.0,2.33551328], #(250)
[6.0,2.34774012195], #(246)
[7.0,2.35156254032], #(248)
[8.0,2.32888475207], #(242)
[8.5,2.34432361789], #(246)
]

Limits_HybridNew = [
[0.2113,3.02228435], #(200)
[0.24,2.97580845771], #(201)
[0.26,2.98139915], #(200)
[0.3,2.99316525], #(200)
[0.33,2.9991437], #(200)
[0.36,3.041728], #(200)
[0.4,2.9968781407], #(199)
[0.43,2.98804386935], #(199)
[0.46,3.00461291457], #(199)
[0.5,3.02047135678], #(199)
[0.53,3.02276502513], #(199)
[0.56,3.02140919598], #(199)
[0.6,2.99831371859], #(199)
[0.7,2.98560532663], #(199)
[0.8,3.02112055276], #(199)
[0.88,3.0378080402], #(199)
[0.9,3.07864070352], #(199)
[0.91,3.01536688442], #(199)
[0.92,3.02529221106], #(199)
[0.93,3.02151829146], #(199)
[0.94,3.02266155779], #(199)
[1.0,3.00756221106], #(199)
[1.1,3.01418321608], #(199)
[1.2,3.70701683417], #(199)
[1.3,3.23422316583], #(199)
[1.4,4.76588703518], #(199)
[1.5,3.38321437186], #(199)
[1.6,3.0034221608], #(199)
[1.7,3.06447085427], #(199)
[1.8,3.16235507538], #(199)
[1.9,3.58412919598], #(199)
[2.0,3.18681522613], #(199)
[2.1,3.02601226131], #(199)
[2.2,3.01883371859], #(199)
[2.3,3.60405226131], #(199)
[2.4,4.3637321608], #(199)
[2.5,3.16800673367], #(199)
[2.6,3.06458984925], #(199)
[2.7,3.81628351759], #(199)
[2.8,4.84471854271], #(199)
[2.9,5.0980060804], #(199)
[3.0,7.01268221106], #(199)
[3.02,7.5134618593], #(199)
[3.05,7.87249542714], #(199)
[3.08,7.67464226131], #(199)
[3.09,7.66184296482], #(199)
[3.1,7.3986821608], #(199)
[3.12,6.8096860804], #(199)
[3.15,5.36357648241], #(199)
[3.2,3.35443678392], #(199)
[3.3,3.00256643216], #(199)
[3.4,3.04975090452], #(199)
[3.7,3.04272843434], #(198)
[4.0,3.07987722222], #(198)
[5.0,3.03155828283], #(198)
[6.0,3.00566683417], #(199)
[7.0,2.99713213198], #(197)
[8.0,3.00079324873], #(197)
[8.5,3.04041461929], #(197)
]




def fCmsLimitVsM_HybridNew(m): # return the limit for a given mass. If the mass point is not present, it makes an interpolation.
  if m >= 0.2113 and m <= 8.55:
    m_im1 = 0.2113
    m_i   = 0.2113
    for i in range(len(Limits_HybridNew)):
      m_i   = Limits_HybridNew[i][0]
      lim_i = Limits_HybridNew[i][1]
      if m == m_i:
        return lim_i
      elif m > m_im1 and m < m_i:
        a = (lim_i - lim_im1) / (m_i - m_im1)
        b = (lim_im1*m_i - lim_i*m_im1) / (m_i - m_im1)
        lim = a*m+b
        return lim
      m_im1 = m_i
      lim_im1 = lim_i
  else:
    print "Warning! Mass if outside the range."

# 2015 Granularity
#MGammaD_array = [0.2113,0.2200,0.2300,0.2400,0.2500,0.2600,0.2700,0.2800,0.2900,0.3000,0.3100,0.3200,0.3300,0.3400,0.3500,0.3600,0.3700,0.3800,0.3900,0.4000,0.4100,0.4200,0.4300,0.4400,0.4500,0.4600,0.4700,0.4800,0.4900,0.5000,0.6000,0.7000,0.8000,0.9000,1.0000,1.1000,1.2000,1.5000,2.0000,2.6000,2.7000,2.8000,2.9000,3.0000,3.1000,3.2000,3.3000,3.4000,3.7000,4.0000,5.0000,6.0000,7.0000,8.0000,8.5000]
# 2016 Granularity
MGammaD_array = [0.2113,0.2400,0.2600,0.3000,0.3300,0.3600,0.4000,0.4300,0.4600,0.5000,0.5300,0.5600,0.6000,0.7000,0.8000,0.8800,0.9000,0.9100,0.9200,0.9300,0.9400,1.0000,1.1000,1.2000,1.3000,1.4000,1.5000,1.6000,1.7000,1.8000,1.9000,2.0000,2.1000,2.2000,2.3000,2.4000,2.5000,2.6000,2.7000,2.8000,2.9000,3.0000,3.0200,3.0500,3.0800,3.0900,3.1000,3.1200,3.1500,3.2000,3.3000,3.4000,3.7000,4.0000,5.0000,6.0000,7.0000,8.0000,8.5000]


## fit the data                                                                                                                                       
def myGaus2(x, mu, sigma):
    #print "type x", type(x)                                                                                                                    
    #return 1./( np.sqrt(2.0*np.pi*sigma**2) ) *  
  return np.exp( - (x - mu)**2 / (2.0*sigma**2) )

## fit the limits
def func(x, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p,q,r,s):
    return ( a + 
             b*myGaus2(x, c, d) + 
             e*myGaus2(x, f, g) +
             h*myGaus2(x, i, j) +
             k*myGaus2(x, l, m) +
             n*myGaus2(x, o, p) +
             q*myGaus2(x, r, s) 
             )

xdata = [float(i[0]) for i in Limits_HybridNew]
ydata = [float(i[1]) for i in Limits_HybridNew]
print xdata
print ydata

"""
For 95% CL limits
                       bounds=([2.95, 
                                0.5, 1.1, 0,  
                                1.75, 1.1, 0, 
                                0.25, 1.7, 0, 
                                1.2, 2.1, 0,
                                0, 2.8, 0,
                                4, 2.9, 0.09],
                               [3.1, 
                                1, 1.3, 0.05, 
                                2, 1.6, 0.05,
                                0.75, 2.1, 0.07,
                                2, 2.7, 0.07,
                                4, 3, 0.07,
                                5, 3.1, 0.13]
                               )

"""

ydata_error = []
for p in range(0,len(xdata)):
  ydata_error.append(0.3)

popt, pcov = curve_fit(func, np.array(xdata), np.array(ydata),
                       sigma = np.array(ydata_error),
                       bounds=([2., 
                                0, 1.1, 0.0,  
                                1.75, 1.1, 0, 
                                0.25, 1.7, 0, 
                                1.2, 2.1, 0,
                                0, 2.8, 0,
                                0, 2.9, 0.0],
                               [2.5, 
                                1, 1.3, 0.03, 
                                2, 1.6, 0.04,
                                0.75, 2.1, 0.07,
                                2, 2.7, 0.07,
                                4, 3, 0.07,
                                5, 3.1, 0.15]
                               )
                       )

print "Fit parameters", popt
print "Fit covariance matrix", pcov

trialX = np.linspace(xdata[0], xdata[-1], 5000)

plt.plot(xdata, ydata, 'o', label='data', markersize=3)
plt.plot(trialX, func(np.array(trialX), *popt), 'r-', label='fit')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()

print (str(popt[0]) + "+" +  
       str(popt[1]) + "* myGaus(m,"+ str(popt[2]) +  ", " + str(popt[3]) + ")" + " + " +
       str(popt[4]) + "* myGaus(m,"+ str(popt[5]) +  ", " + str(popt[6]) + ")" + " + " +
       str(popt[7]) + "* myGaus(m,"+ str(popt[8]) +  ", " + str(popt[9]) + ")" + " + " +
       str(popt[10]) + "* myGaus(m,"+ str(popt[11]) +  ", " + str(popt[12]) + ")" + " + " +
       str(popt[13]) + "* myGaus(m,"+ str(popt[14]) +  ", " + str(popt[15]) + ")" + " + " +
       str(popt[16]) + "* myGaus(m,"+ str(popt[17]) +  ", " + str(popt[18]) + ")"
       )
       
#print "Fit parameters", popt 
#print "Fit covariance matrix", pcov

#plt.show()
